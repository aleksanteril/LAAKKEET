#include <math.h>
#include <stdio.h>
#include "hardware/gpio.h"
#include "pico/time.h"

//Pins
#define OPTO_F 28
#define IN1 2
#define IN2 3
#define IN3 6
#define IN4 13

#define COIL1 0
#define COIL2 1
#define COIL3 2
#define COIL4 3

//
#define CALIB_SAMPLE_SIZE 3.0
#define BLOCKS 8.0
#define COILS 4
#define STEPS 8

//Different 0 and 1
#define NO 0
#define YES 1
#define OFF 0
#define ON 1

//Values for calculating the steps
#define CALIB_SAMPLE_SIZE 3.0
#define BLOCKS 8.0
#define COILS 4
#define STEPS 8
#define THEORETICAL_STEPS_IN_A_REVOLUTION 4096



typedef struct Machine_t {
    state state;
    uint8_t pill_count;
    uint32_t timer;
    bool calibrated;
    uint8_t turn_count;
    int step_cycle; //The step of the cycle the coils currently are
    int step_in_revolution;
} Machine_t;

void one_step(int step) {
    int pins[COILS] = {IN1, IN2, IN3, IN4};
    int cycle[STEPS][COILS] = {
        {ON, OFF, OFF, OFF},
        {ON, ON, OFF, OFF},
        {OFF, ON, OFF, OFF},
        {OFF, ON, ON, OFF},
        {OFF, OFF, ON, OFF},
        {OFF, OFF, ON, ON},
        {OFF, OFF, OFF, ON},
        {ON, OFF, OFF, ON}
    };

    gpio_put(pins[COIL1], cycle[step][COIL1]);
    gpio_put(pins[COIL2], cycle[step][COIL2]);
    gpio_put(pins[COIL3], cycle[step][COIL3]);
    gpio_put(pins[COIL4], cycle[step][COIL4]);
    sleep_ms(3);
}

void step_checker(int *step) {
    //Checks if the steps have made a full circle and returns it back to start
    if (*step == STEPS) {
        *step = 0;
    }
}

void full_round(Machine_t *m) {
    //Drives full round (8 steps) so that it stops at step 7 so the driving can start from the step 0
    int start_up_step = -1;
    for (int i = 0; i < STEPS; i++) {
        start_up_step++;
        step_checker(&start_up_step);
        one_step(start_up_step);
    }
    m-> step_cycle = start_up_step;
}

int limit_switch_check() {
    if (!gpio_get(OPTO_F)) {
        return YES;
    }else {
        return NO;
    }
}

void error_check(int steps_total, int *error, int revolutions) {
    if (revolutions == -1 || revolutions == 0) {
        if (steps_total > THEORETICAL_STEPS_IN_A_REVOLUTION * 1.1) {
            *error = true;
        }
    }else {
        if (steps_total / revolutions > THEORETICAL_STEPS_IN_A_REVOLUTION * 1.1) {
            *error = true;
        }
    }
}

void calibrate_position(Machine_t *m) {
    int revolutions = -1;
    double steps_total = 0;
    double average_steps_revolution = 0;
    double steps_total_gaps = 0;
    double average_steps_gap = 0;
    double steps_left = 0;
    int in_gap = NO;
    double steps_in_block = 0;
    int error = false;

    //Find the first rising edge
    printf("Calibrating...\n");
    while (revolutions == -1 && error == false) {
        m->step_cycle ++;
        step_checker(&m->step_cycle);
        one_step(m->step_cycle);
        if (limit_switch_check() == YES && in_gap == NO) {
            in_gap = YES;
        }else if (in_gap == YES) {
            if (limit_switch_check() == NO) {
                in_gap = NO;
                revolutions++;
            }
        }
        steps_total++;
        error_check(steps_total, &error, revolutions);
    }
    steps_total = 1; //Step counter is set to 1 after finding the first rising edge

    //Start the calibration after finding the first rising edge
    while (revolutions < CALIB_SAMPLE_SIZE && error == false) {
        m->step_cycle++;
        step_checker(&m->step_cycle);
        one_step(m->step_cycle);
        if (in_gap == NO) {
            if (limit_switch_check() == YES) {
                in_gap = YES;
                steps_total_gaps++;
            }
        }else if (in_gap == YES) {
            if (limit_switch_check() == NO) {
                in_gap = NO;
                revolutions++;
            }else {
                steps_total_gaps++;
            }
        }
        if (revolutions < CALIB_SAMPLE_SIZE) {
            steps_total++;
        }
        error_check(steps_total, &error, revolutions);
    }
    
    if (error == false) {
        average_steps_revolution = steps_total / CALIB_SAMPLE_SIZE;

        steps_in_block = average_steps_revolution / BLOCKS;
        average_steps_gap = steps_total_gaps / CALIB_SAMPLE_SIZE;

        //Device "starts seeing" the gap x steps too late and "stops seeing" the gap x steps too early.
        //Subtracting x from full blocks steps the wheel turns in a correct position
        steps_left = steps_in_block - average_steps_gap/2;
        for (int i = 0; i < round(steps_left); i++) {
            m->step_cycle++;
            step_checker(&m->step_cycle);
            one_step(m->step_cycle);
        }
        m->step_in_revolution = (int)round(average_steps_revolution);
        m->calibrated = true;
        printf("Calibration completed successfully!\n");

    }else {printf("-----------------------------------\n");
        printf("Calibration failed. Please check your hardware is working properly.\n");
        printf("-------------------------------------------------------------------\n");
    }
}

void calibrate(Machine_t *m) {
    full_round(m);
    calibrate_position(m);
}